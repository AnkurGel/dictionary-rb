#!/usr/bin/env ruby
require "thor"
require "dictionary-rb"

class DictionaryRB_CLI < Thor

  desc "meaning WORD", "gives dictionary meaning of the WORD"
  option :words, :desc => "Specify multiple WORDS in succession", :type => :array
  option :file, :type => :boolean, :desc => "Pass file(s) as argument(s) instead."
  option :example, :type => :boolean, :desc => "Generate an example too."
  option :similar, :type => :boolean, :desc => "Generate a synonym too."
  def meaning(word=nil)
    urban_or_dictionary_meaning(word, options, :dictionary)
  end


  desc "urban WORD", "gives UrbanDictionary meaning of the WORD"
  option :words, :desc => "Specify multiple WORDS in succession", :type => :array
  option :file, :type => :boolean, :desc => "Pass file(s) as argument(s) instead."
  option :example, :type => :boolean, :desc => "Generate an example too."
  option :similar, :type => :boolean, :desc => "Generate a synonym too."
  def urban(word=nil)
    urban_or_dictionary_meaning(word, options, :urban)
  end


  desc "similar WORD", "gives syonyms of word(s)"
  option :words, :desc => "Specify multiple WORDS in succession"
  option :file, :type => :boolean, :desc => "Pass file(s) as arugment(s) instead."
  option :urban, :type => :boolean, :desc => "Give similar word from Urban Dictionary"
  option :count, :type => :numeric, :desc => "Gives N similar words"
  def similar(word=nil)
    words = options_simplifier(word, options)
    method = options[:urban] ? :urban : :dictionary
    words.each do |word|
      obj = DictionaryRB::Word.new(word).method(method).call
      words = obj.similar_words.shuffle.first(
          options[:count] ? options[:count] : 1)
      say "#{word} is similar to - #{words.join(", ")}"
    end
  end


  desc "examples WORD", "gives examples of word(s)"
  option :words, :desc => "Specify multiple words in succession"
  option :file, :type => :boolean, :desc => "Pass file(s) as arugment(s) instead."
  def examples(word=nil)

  end


  private
  def options_simplifier(word, options)
    if options[:file]
      files_path = options[:words] ? options[:words] : [word]
      words = files_to_words files_path
    elsif options[:words] #no 'file' flag is found, but 'words' options are
      words = sanitize_options_words(options[:words])
    else
      words = [word]
    end
    words
  end

  def urban_or_dictionary_meaning(word, options, method)
    words = options_simplifier(word, options)
    words.each do |word|
      obj = DictionaryRB::Word.new(word).method(method).call
      meaning = obj.meaning
      example = options[:example] ? " - " + obj.examples.first : ""
      similar = options[:similar] ? " - " + obj.similar_words.first : ""
      say "#{word} - #{meaning}#{example}#{similar}"
    end
  end

  def files_to_words(files)
    files.map do |file|
      file_path = File.expand_path(file)
      raise ArgumentError, say("Error: File #{file_path} doesn't exists!", :red) unless File.exists?(file_path)
      File.open(file_path, 'rb').read.split("\n").map do |word|
        raise ArgumentError, "Error: Not a valid word - #{word}, :red" unless word.strip.match(/^\w+$/)
        word
      end
    end.flatten.uniq
  end

  def sanitize_options_words(words)
    words.map do |word|
      raise ArgumentError, "Error: Not a valid word - #{word}, :red" unless word.strip.match(/^\w+$/)
      word
    end
  end


end

DictionaryRB_CLI.start
